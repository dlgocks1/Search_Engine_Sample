レベル: 初級Paul Duvall, CTO, Stelligent 2009年 1月 13日Java™ デプロイメントは大抵の場合、面倒でエラーを起こしやすい手作業です。そして、それが原因でユーザーがソフトウェアを利用できるようになるまで時間がかかることは珍しくありません。連載「万人のためのオートメーション」の今回は、2 回からなる連載記事の第 1 回目として、オートメーションのエキスパート Paul Duvall が、信頼性が高く、一貫性のある繰り返し可能なデプロイメント・プロセスを作成するための重要なパターンをまとめて紹介します。このデプロイメント・プロセスは、ワン･クリックで Java アプリケーションをデプロイすることができます。
ソフトウェア・デプロイメントは、ソフトウェアを存続させるために事前にどうにか取り繕うべき必要悪として扱われることがよくあります。しかし、そんなデプロイメントにも他の開発サイクルと同様にソフトウェア・エンジニアリングの原則を適用することはできます。そして、本来そうあるべきです。手作業でのデプロイメントは、エラーを起こしやすい繰り返しのプロセスだからです。ビルドを自動化することでエラーの削減とソフトウェア開発期間の短縮を実現できるのとまったく同様に、デプロイメント・プロセスを自動化することによって、エラーを削減し、ソフトウェア・デリバリーを迅速に行うことができます。
「万人のためのオートメーション」の以前の記事、「オートメーションによるデプロイメントの円滑化」では、リモートでソフトウェアを複数のターゲット環境にデプロイする方法を説明しました。今回の 2 回からなる連載記事では、さらに高度な自動デプロイメントを紹介します。ソフトウェア開発にパターンがあるように、デプロイメントにもパターンがあります。私はこの数年の間、これらのパターンを集めてきました。第 1 回目のこの記事では、以下の 8 つのデプロイメント・パターンとそれぞれの事例を説明します。
中央リポジトリーでの全構成ファイルの管理。このように管理することによって、スクリプト化デプロイメントを使用して実動ソフトウェアを生成できるようになります。 
スクリプト化デプロイメント。すべてのデプロイメント・アクションをスクリプトにすることで、人間が介入しなくてもデプロイメントを実行できるようにします。 
シングル・コマンド。デプロイメントの複雑さを軽減するとともに、デプロイメント・プロセスのヘッドレス実行を確実にします。 
構成のトークン化。繰り返し可能な方法で可変情報を構成ファイルに注入できるようになります。 
構成の外部化。ターゲット環境間で異なる情報の入力が一度だけでよくなり、簡単になります。 
テンプレート・ベリファイヤー。すべてのターゲット環境プロパティーが同じであることを確実にします。 
ヘッドレス実行。自動プロセスで複数のマシンにアクセスするセキュアな方法です。 
統一されたデプロイメント。1 つのデプロイメント・スクリプトを多数のターゲット環境で実行できるようにします。 
第 2 回では、上記以外のデプロイメント・パターンについても説明します。
この連載について 
私たちは開発者として、エンド・ユーザーのプロセスを自動化するために作業しますが、自分自身の開発プロセスを自動化する機会は見落としがちです。そこで、連載記事「万人のためのオートメーション」では、実用的なソフトウェア開発プロセスの自動化を検討し、自動化を上手に適用するタイミングと方法を教えます。
図 1 に、この記事で取り上げるデプロイメント・パターンの相関関係を示します。
図 1. デプロイメント自動化パターン 
これから、上記のパターンについて 1 つひとつ説明していきます。説明を読んでいくうちに、図 1 に示した相関関係がわかってくるはずです。
すべてのファイルをバージョン管理リポジトリーにコミットする
名前: リポジトリー
パターン: すべてのファイルをバージョン管理リポジトリーにコミットします。デプロイメントのコンテキストで言うと、すべての構成ファイルとツールをコミットします。
アンチパターン: この情報をアクセスが制御された共有ドライブに保管しているチームや、自分たちのマシンにだけ情報を保持し、ターゲット環境には情報をコピーするという方法を採っているチームがあります。
原則として、開発チームは実動ソフトウェアの作成に必要となる自分たちのファイルをすべて、チェックインすることを推奨します。この原則に当てはまらない場合もあるにせよ、そのような例外は多くありません。デプロイメントのコンテキストでは、チームがサーバーとサーバー構成を固定資産、つまり変更されることのない資産だと思っていることがありますが、それは誤った見方です。大規模なバイナリーをチェックインする上で制約が課せられる場合もありますが、構成ファイル、データベース・スクリプト、そしてすべてのビルド・スクリプトとデプロイメント・スクリプトは、バージョン管理リポジトリーにコミットするべきです。このリポジトリーのパターンを使用すると、これから説明するパターン (スクリプト化デプロイメントのパターン、そしてシングル・コマンドのパターンの場合は特に) に非常に役に立ちます。
すべてのデプロイメント・プロセスをスクリプトにする
名前: スクリプト化デプロイメント
パターン: すべてのデプロイメント・プロセスをスクリプトにします。
アンチパターン: Web コンテナーのインストールや構成などのタスクを手作業で構成する人もいれば、特定の環境に合わせてコンテナーを変更するために、コンテナーが提供する GUI ベースの管理ツールを使う人もいます。構成を手作業で変更する人はあまりいないかもしれませんが、最初のうちは簡単なこの方法は、多数のターゲット環境を対象に 1 週間に何度もデプロイメントを行うとしたら、手作業では対応しきれなくなります。また、デプロイメントには GUI ベースの管理ツールが大いに役立つものの、それも最初のうちに過ぎません。GUI ベースの管理ツールでデプロイするとしても、多数の人々がその手順を何度も実行することになれば、拡張に対応できないだけでなく、エラーの原因にもなりがちです。
リスト 1 に記載するスクリプト化デプロイメント・パターンでは、デプロイメントをスクリプトにすることで、Tomcat Web コンテナーの (再) 起動プロセスを自動化しています。このプロセスは、Apache Ant ビルド・スクリプト言語によって作成されています。
リスト 1. Tomcat Web コンテナーの起動例 
<available file="@{tomcat.home}/server/@{tomcat.server.name}/bin" 
property="tomcat.bin.exists"/>
<if>
<isset property="tomcat.bin.exists"/>
<then>
<echo message="Starting tomcat instance at @{tomcat.home} with start_tomcat" />
<exec executable="@{tomcat.home}/server/@{tomcat.server.name}/bin/start_tomcat" 
osfamily="unix" />
</then>
<else>
<echo message="Starting tomcat instance at @{tomcat.home} with startup.sh" />
<exec osfamily="unix" executable="chmod" spawn="true">
<arg value="+x" />
<arg file="@{tomcat.home}/bin/startup.sh" />
<arg file="@{tomcat.home}/bin/shutdown.sh" />
</exec>
<exec executable="sh" osfamily="unix" dir="@{tomcat.home}/bin" spawn="true">
<env key="NOPAUSE" value="true" />
<arg line="startup.sh" />
</exec>
<exec osfamily="windows" executable="cmd" dir="@{tomcat.home}/bin" spawn="true" >
<env key="NOPAUSE" value="true" />
<arg line="/c startup.sh" />
</exec>
<sleep seconds="15" />
</else>
</if>
イテレータにご注意！次のコードは少しパフォーマンス的に勿体無いです。メモリ的にも、実行速度的にもです。さて、どこが勿体無いのでしょうか？#include <cstdlib> #include <iostream> #include <vector> int main() { std::vector<int> v; /* 乱数で初期化 */ for (int i = 0; i < 10; i++) { v.push_back( rand() ); } /* 全部表示 */ std::vector<int>::iterator it; const std::vector<int>::const_iterator & end = v.end(); for (it = v.begin(); it != end; it++) { std::cout << *it << std::endl; } return 0; } 答え答えは、下から5行目のここ→「it++」。for文中でイテレータを後置インクリメントしている箇所です。
理由後置インクリメントの実装を考えてみましょう。後置インクリメントは、次のように実装されています。現在の値を覚える。←一時オブジェクト！値をインクリメントする。覚えておいた値を返す。後置インクリメントだと、上記のようにどうしても一時オブジェクトを作る必要が出てきます（クラスメンバに隠すという手もありますが）。そのため、for文がまわるたびに一時的なオブジェクトが作られては破棄されていき、メモリ的にも速度的にも無駄が出てしまいます。実のところ上記の例では、ポインタサイズ分程度の無駄しかありません。しかし自前クラスのイテレータなどでは、ポインタサイズよりも大きなサイズの無駄が出る可能性があります。この意味で、イテレータのインクリメントにはいつも注意すべきです。
イテレータは、前置インクリメントで！前置インクリメントの場合は、次のように実装されています。インクリメントする。現在の値を返す。後置インクリメントと違って、一時オブジェクトを作る必要がありません。このためイテレータを使って要素をなめる際には、次のように前置インクリメントを使うようにしましょう。#include <cstdlib> #include <iostream> #include <vector> int main() { std::vector<int> v; /* 乱数で初期化 */ for (int i = 0; i < 10; i++) { v.push_back( rand() ); } /* 全部表示 */ std::vector<int>::iterator it; const std::vector<int>::const_iterator & end = v.end(); for (it = v.begin(); it != end; ++it) { std::cout << *it << std::endl; } return 0; } 補足１　～なぜ「値を返す」のか～そもそもインクリメントの際に「値を返す」必要がなければ、一時オブジェクトは必要ありません。が、そもそも次の式のような操作をしたいがために、やはり値を返す必要があります。it2 = ++it1; 補足２　～もう1箇所～実は、もう1箇所、メモリ的な無駄があります（コンパイラ依存で）。 それは・・・、どこでしょう？ 答えは、またの機会に・・。 （C++0xで言えば、さらにもう1箇所・・）以上
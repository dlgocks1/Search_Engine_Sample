＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
■■■■
■　　　　■　　　　　　　■　　　　　　　　■
■　　　　　　　　　　　■■■　　　　　　■■■
■　　　　■　　　　　　　■　　　　　　　　■
■■■■
～基礎から　★　Ｃ＋＋Ｐｒｏｇｒａｍｉｎｇ～
＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
【注意】　このマガジンは、最大化してお読みください。
また、等角フォントでお読みください。
（ＭＳ　ゴシックなど）
＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
発行者　　　　　　むーくん
マガジンＮＯ．　　アルゴリズム編 No.57 離散フーリエ変換
発行日　　　　　　02/10/20
講読人数　　　　　３８００名ぐらい
マガジンＩＤ　　　0000050494
このマガジンは、まぐまぐから配信されています。
＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
★あいさつ★
今回扱う離散フーリエ変換というのは予想以上に応用範囲が広くて、
有名なところでは、画像圧縮のJPEG方式で
離散コサイン変換という形で登場していますし、
意外なところでは、多倍長演算でのかけ算アルゴリズムなどに
用いられていたりします。
余裕があったらこういったアルゴリズムも取り上げていきたいので
応援よろしくお願いします。
今回の内容は、信号計測の分野にも足を突っ込んでますので
イメージを掴めるところから読んでいくといいと思います。
信号計測もそれだけで奥が深くて面白いんですけどね。
＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
■退職金くじ１０万円【この場】で当る！ http://www.jobfront.to/a.html
＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
★目次★
・A-D変換、D-A変換
・サンプリング
・量子化
・コラム・音声の話
・離散フーリエ変換(DFT)
・サンプルプログラム
・出力データに対する考察
・今日のポイント
・予告
＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
★A-D変換、D-A変換★
普通、コンピュータ上では連続的な波形を取り扱うことはできません。
なので、どうしてもある間隔で値を取り出し、
離散的な波形に変換する必要がでてきます。
連続的な波形のことを「アナログ信号」、
離散的な波形のことを「ディジタル信号」といいます。
例えば、音楽の情報はアナログ信号ですから、
コンピュータ上で扱うにはディジタル信号に変換します。
アナログ信号をディジタル信号に変換することを「A-D変換」といいます。
逆にディジタル信号を、人間が聞く音楽にするためには
アナログ信号に戻す必要があります。
ディジタル信号をアナログ信号に変換することを「D-A変換」といいます。
＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
★サンプリング★
A-D変換をするときなど、
データを取り出すことを「サンプリング」といいます。
サンプリングでは、等間隔でデータを取り出すことが前提とします。
＃　↑　ここは重要です
その取り出す間隔を表す周波数を
「サンプリング周波数：fs」と呼びます。
サンプリング周波数はよく考えないと、A-D変換→D-A変換したときに
元のデータが復元できないという自体に陥ってしまうので重要です。
例えば、1秒間に100回変動する信号をサンプリングしようとしたとき、
1秒間に1回しかデータを取り出さなかったとします。
すると、残りの99回分の変動データは取り出していないので
失われてしまいます。
結果として、D-A変換しても元のデータは復元できません。
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
こんなことが起きないようにサンプリングするためには、
もとの信号の１周期間に、最低２回サンプリングする必要があります。
もとの信号の周波数をfとするならば、
2f ≦ fs 
という関係が成り立ちます。
これを「ナイキストのサンプリング定理」といいます。
f(x)=sin(x)の波形を2倍のサンプリング周波数で
A-D変換→D-A変換した図を下に示します。
http://members.tripod.co.jp/mukun_mmg/mmg/bncpp/graph_al057a.gif
周波数が同じ正弦波が復元されていることが分かると思います。
しかし一般的には、このように波形の振幅と角度がずれてしまいます。
ここから分かるとおり、
「波形が復元されるとは、周波数が維持されること」です。
データをディジタル化するということは、
このように、ある種のデータは必ず失われることに注意してください。
＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
★量子化★
波形は一般的には連続波形ですから、
やはりコンピュータ上で扱うためには離散値に近似しなければなりません。
例えば、sin(2π/3) = √3 / 2　ですが、
無理数は扱えないので、どこかで四捨五入ことになります。
＃量子化する場合、普通は四捨五入などせずに、単に切り捨てますが
A-D変換は、「サンプリング」と「量子化」をすることで実現されます。
サンプリングは横軸の近似、量子化は縦軸の近似だということです。
＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
★コラム・音声の話★
CDオーディオも音楽をA-D変換したデータを用いていますから
当然、サンプリング→量子化という過程を踏んでいます。
よく目にするかどうかは知りませんが ^^;
「ビットレート 16bit・サンプリング周波数 44.1kHz」などという
ものを見たことがあるかも知れません。
＃むしろ今は、mp3などで見かける方が多いかも知れませんね
これはどういう意味かというと、
量子化を16bit、つまり2^16(65536)段階で近似し、
サンプリング周波数を44100HzでA-D変換しているということです。
この数値にどういう根拠があるのかというと、
人間の可聴周波数に関係があります。
人間の耳は個人差こそありますが、約20～20000Hzまでの周波数の
音しか聞くことができません。
つまり、人間に関係ある最大の周波数成分は20000Hzであるわけです。
ということはその2倍でサンプリングすれば
再現性のある波形を復元できますから、
約40000Hzのサンプリング周波数になっているのです。
＃サンプリング定理そのものですね
一方、電話でも似たような話があります。
電話でもやはり、音声は20kHz以下の成分しか必要ありません。
よって、それよりも高い周波数成分はカットされているのです。
＃高い音がでる鈴の音などが聞こえにくいのはそのためです
これって、以前『伊藤家の食卓』とかで見たことのある気が・・・
ADSLで高周波(数MHz～数GHz)を利用できるのは、
音声が20kHz以下の低周波しか使わないからだったのですね。
同じ回線を使いながらどうして混線しないのだろう・・・？？
と思っていませんでしたか？
＃逆にディジタル信号であるISDNは高周波成分を含んでいます
お互いに干渉するので、ADSLと相性が悪いのはそのためです
＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
★離散フーリエ変換(DFT)★
閑話休題、いよいよ本筋です。
フーリエ変換(FT)は連続な信号を対象として扱ってきましたが、
コンピュータではやはり、離散化した信号として用いる必要があります。
これを「離散フーリエ変換(Discrete Fourier Transform : DFT)」といいます。
要するに、サンプリングされたデータから
元の信号の周波数成分を分析することです。
さて、ある周期信号f(t)をP等分し、n番目に得られた信号をf_nとします。
＃f_0は最初の値、f_1はその次の値・・・ということです。
よって、n = 0,1,・・・,P-1です。
すると、離散フーリエ変換は以下のように定義されます。
F_n = Σ[m = 0～P-1] a_m・W_P_(nm)
＃W_P_(nm) = exp[(-2πi/P)nm]でしたね。
離散値なので、積分ではなく、シグマになります
a_mはフーリエ係数ですから、周波数成分そのものです。
なので、実際の計算では、a_mを求めることが目標です。
a_mは以下のように計算できます。
a_m = 1/P Σ[n = 0～P-1] F_n・W_P_(nm)
実際には値が実数部(cos)、虚数部(sin)に分かれるので
a_real,a_imaginaryとして別々に求めることになります。
＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
★サンプルプログラム★
関数f(n)をDFTするプログラムを作成します。
ある観測波形を周期間で10点サンプリングしたところ、
以下のようなデータが得られました。
[2.0,1.145,-4.471,4.471,-1.145,-2.0,2.381,-1.235,1.235,-2.381]
このデータより、元の波形を求めます。
#include<iostream>
#include<cmath>
using namespace std;
const int P = 10; /* サンプリングデータ数 */
const double PI = 3.1415926; /* 円周率 */
int main(){
/* サンプリングデータ */
double f[P] = {2.0,1.145,-4.471,4.471,-1.145,
-2.0,2.381,-1.235,1.235,-2.381};
double a_real,a_imaginary,x; /* 実数部、虚数部 */
int m,n;
cout << "次数\tREAL\tIMAGINARY" << endl;
for(m=0;m<P;m++){ /* DFT計算部 */
a_real = a_imaginary = 0.0; /* 値をクリアする */
for(n=0;n<P;n++){
x=2.0*PI/P*m*n; /* exp()の中身 */
a_real += f[n]*cos(-x)/P; /* 実数部の演算 */
a_imaginary += f[n]*sin(-x)/P; /* 虚数部の演算 */
}
cout.precision(3); /* 表示 */
cout.setf(ios::fixed); /* 小数点表記にしている */
cout << m << '\t' << a_real << '\t' << a_imaginary << endl;
}
return 0;
}
─[解説]────────────────────────────────
フーリエ係数a_m = 1/P Σ[n = 0～P-1] F_n・W_P_(nm) なので、
a_0 = 1/P Σ[n = 0～P-1] F_n・W_P_(0)
a_1 = 1/P Σ[n = 0～P-1] F_n・W_P_(n)
a_2 = 1/P Σ[n = 0～P-1] F_n・W_P_(2n)
・
・
a_P-1 = 1/P Σ[n = 0～P-1] F_n・W_P_[(P-1)n]
と次数ごとにmが変動しますから、
外側のforループではmを0～P-1まで動かしています。
内側のforループでは式の通り、
nを0～P-1まで動かして値を計算しています。
W_P_(mn)の部分は、実数部をcos(-2πmn/P)、虚数部をsin(-2πmn/P)
として求めます。おなじみのオイラーの公式ですね。
2πmn/Pは両方に共通するため、先にx=2πmn/Pとして計算しています。
─[実行結果]──────────────────────────────
次数 REAL IMAGINARY
0 0.000 0.000
1 0.000 -0.000
2 0.000 0.000
3 1.000 0.000　　　　← exp(i3t)
4 0.000 -1.500　　　　← -1.5exp(i4t)i
5 -0.000 0.000
6 -0.000 1.500　　　　　← 1.5exp(i6t)i
7 1.000 0.000　　　　← exp(i7t)
8 -0.000 -0.000
9 0.000 -0.000
ここから
f(t) = exp(i3t) - 1.5exp(i4t)i + 1.5exp(i6t)i + exp(i7t)
であることが読みとれます。
ただし、expの周期性 W_P_(K-P) = W_P_Kを用いると
exp(i6t) = exp(-i4t), exp(i7t) = exp(-i3t)
であることが分かります。
＃今、P=10なので、6-10=-4, 7-10=-3ですね
よく分からない方はバックナンバーアルゴリズム編No.55を参照ください
よって、式を整理して
f(t) = [exp(i3t)+exp(-i3t)] - 1.5[exp(i4t)-exp(-i4t)]i
= 2 cos(3t) + 3 sin(4t)
になります。
＃オイラーの公式より得られる
2cos(x) = exp(ix)+exp(-ix)
-2i sin(x) = exp(ix)-exp(-ix)　を使っています
結局、元の関数は 2 cos(3t) + 3 sin(4t)であること分かりました。
2 cos(3t) + 3 sin(4t)は↓のような信号です。
http://members.tripod.co.jp/mukun_mmg/mmg/bncpp/graph_al057b.gif
────────────────────────────────────
＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
★出力データに対する考察★
次数 REAL IMAGINARY
0 0.000 0.000
1 0.000 -0.000
2 0.000 0.000
3 1.000 0.000
4 0.000 -1.500
5 -0.000 0.000　　　－－－－ P/2 －－－－
6 -0.000 1.500
7 1.000 0.000
8 -0.000 -0.000
9 0.000 -0.000
これは、2 cos(3t) + 3 sin(4t)をP=10でDFTして得られた値ですが、
よく見ると気づく点があります。
実数部はP/2に対して対称、虚数部も符号が逆ですが対称です。
＃-0,+0は計算誤差なので無視しています。
だから本来は、P/2の次数までしか計算しなくても良いのです。
＃というよりP/2以上のデータはサンプリング定理から
出てくるはずのない信号であり、偽物です。
これは指数関数の周期性から、負の周波数成分と考えるべきですね。
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
もう一つ、この結果から、サンプリング定理の正しさも考察できます。
もしもsin(5t)という成分が含まれていたならば、
P/2 = 5ですから、
次数5のところにプラス成分とマイナス成分がぶつかって消えてしまいます。
だから、データが復元されることはありません。
このように、対称成分の信号がぶつかって現れる誤差を
「エイリアシング誤差」といいます。
サンプリング定理の限界を超える周波数をサンプリングすると
エイリアシング誤差により、正しく復元することができません。
DFTを用いる際に、もとの波形データをサンプリングすることになりますが、
サンプリング周波数をよく吟味しないと幻の波形を掴まされることになるので
よく注意しましょう。
＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
★今日のポイント★
・サンプリングとは、波形から一定の時間間隔で値を取り出すことである
・量子化とは、取り出した値を近似することである
・もとの波形の2倍以上の周波数でサンプリングしないと
D-A変換後に波形を復元することはできない。
これをサンプリング定理という。
・離散フーリエ変換(DFT)とは、
サンプリングされた値から周波数成分を分析することである。
・フーリエ変換されたデータは
実数部が対称に、虚数部が符号逆転で対称に現れる
＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
★予告★
高速フーリエ変換(FFT)を学習します
＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
講読解除はこちら
http://web1.freecom.ne.jp/~mu-home/mmg/cpp.html
バックナンバーはこちら
http://web1.freecom.ne.jp/~mu-home/mmg/cpp.html
内容について質問やご意見など
smukun.com
筆者のホームページ（むーくんの理学的なんでも講座）
http://www.hello.sh/nandemo/
＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
2009年7月6日
Google App Engine Java: JPA and Datastore3
今回も引き続き、Google App Engine JPA の使用方法に関するポイントを解説したいと思います。 まずは、Google App Engine JPA EntityManager の使用方法から。 EntityManagerFactory は、Singleton インスタンスとして管理する必要があります。EntityManagerFactory を重複して生成しようとした場合、IllegalStateException で処理が失敗します。Using JPA with App Engine を参考に、EMF.java のような Singleton wrapper クラスを作成してもよいですし、Jazzmaster framework を使用して、EntityManagerFactory を Application scoped インスタンスとして管理してもいいでしょう。Unit test 時など、どうしても EntityManagerFactory を重複して作成したい場合、appengine-web.xml に、システム・プロパティ appengine.orm.disable.duplicate.emf.exception を追加し、値を true にすることで、例外を回避できます。EntityManager を閉じるタイミングに注意する必要があります。EntityManager から取得したエンティティが他のエンティティを所有している場合、所有されている子エンティティは Lazy loading でフェッチされます。従って、子エンティティを取得する前に EntityManager を閉じてしまうと、org.datanucleus.exceptions.NucleusUserException: Object Manager has been closed という例外で処理が失敗します。これは JPA のマッピングでも考慮しなければならないポイントですが、Google App Engine JPA では、特に javax.persistence.Query#getResultList() によって取得した List 内の各エンティティも Lazy loading でフェッチされるということを知っておく必要があります。一見問題無いように見える以下のコードは、Google App Engine JPA では失敗します（もともと Java Pet Store Reference Application が提供されている Glassfish V2 Java EE 5 SDK と javadb database 環境では、もちろん動きます）。public List<TestEntity> getTestEntities() { EntityManagerFactory entityManagerFactory = Persistence.createEntityManagerFactory("transactions-optional"); EntityManager entityManager = entityManagerFactory.createEntityManager(); Query query = entityManager.createQuery("SELECT FROM " + TestEntity.class.getName()); List<TestEntity> list = query.getResultList(); // Too early! entityManager.close(); return list; } アプリケーションは、必要な全てのエンティティにアクセスした後で、EntityManager を閉じるべきなのですが、これが一筋縄ではいきません。全てのエンティティのアクセスが終わるまで EntityManager のインスタンスを保持しておくとなると、アプリケーションによっては、JSP などのプレゼンテーションコンポーネントまで EntityManager を引き継いでおく必要が出てくるため、コンポーネントの分割を妨げる、もしくはコンポーネントどうしの結合度を強めてしまう可能性があります。逆に、コンポーネントを適切に分割した上で、データストアを操作するコンポーネントにて EntityManager を閉じようとする場合、クライアントに結果セットを戻す前に、全てのエンティティに事前にアクセスしておく必要があり、処理性能上のオーバーヘッドとなるばかりか、本来不要なロジックが入り込むことによってコードの透明性を落とす可能性があります。Java Pet Store Reference Application on Google App Engine Java では、Jazzmaster の文脈管理とライフサイクル管理を用いてこの問題を効率的に解決しています。Java Pet Store Reference Application on Google App Engine Java では、EntityManager を HTTP リクエスト・スコープのサービスとして管理しており、HTTP リクエストが生成される度に EntityManager のインスタンスを生成、HTTP リクエストが破棄されるタイミングで、EntityManager を閉じる、ということを行っています。これによって、アプリケーションは、いつ EntityManager を閉じるべきかという問題に頭を悩ませる必要が無くなり、とてもコードがシンプルになっています（EntityManager を閉じるコード自体を書く必要がなくなります）。「EntityManager をいつ閉じるか」なんて、アプリケーションが本来必要としているロジックとは全く関係ありませんよね。コンポーネントの組み立て／文脈管理／ライフサイクル管理など、アプリケーションが本来必要としていないロジックをアプリケーションのコードから取り除くことができる、というのも Jazzmaster のパワーの１つです。Jazzmaster の回で詳しく説明します。 このように、Google App Engine JPA では、データストア操作がシステムのボトルネックにならないよう、徹底的に処理の効率化が図られており、アプリケーションも Google App Engine JPA 特有の仕様に合わせてコードを書く必要があります。 それでは、JPQL にいきます。まずは代表的な Bug から。 JPQL の実行が org.datanucleus.exceptions.ClassNotResolvedException で失敗するhttp://groups.google.com/group/google-appengine-java/browse_thread/thread/834772a93944be92/b6a4c7d357e69cf5?lnk=gst&q=ClassNotResolvedException DataNucleus の Bug です。JPQL に記述するエンティティのクラス名を、完全修飾名にすることで対応します。 setParameter と setFirstResult, setMaxResults の組み合わせが機能しないhttp://groups.google.com/group/google-appengine-java/browse_thread/thread/55ccc8d2d2beebe8 http://code.google.com/p/datanucleus-appengine/issues/detail?id=38 こちらも、DataNucleus の Bug です。setFirstResult, setMaxResults の後で setParameter を呼び出すことで対応します。1.0.2 で対応されます。 ・・・などなど。上記は Java Pet Store Reference Application の実装時によく遭遇した Bug ですが、これ以外にも DataNucleus plugin for Google App Engine は正直まだ少し不安定な印象です。データストアの Bug かなと思ったら、http://code.google.com/p/datanucleus-appengine/issues/list を確認しましょう。Bug を回避するための代替手段が記載されている場合もあります。 また、Google App Engine データストアは Relational database ではありませんので、Google App Engine JPA ではアプリケーションでエンティティの関連解決を行う割合が大きくなります。Unsupported Features of JPA に記載されている通り、Google App Engine JPA でサポートされない JPA の機能は、すべてアプリケーションで独自に対応する必要があります。 ここでは、Google App Engine JPA の使用方法に関する最後の Tips として、エンティティの関連解決に関する２つの非サポート機能 多対多関連（非所有関係の表現）Join クエリーをアプリケーションでどのように実装するかについて解説します。 前回の投稿 Google App Engine Java: JPA and Datastore2 で解説した通り、所有関係下にないエンティティの関連と多対多関連の解決は、アプリケーション側で行う必要があります。http://code.google.com/p/jazzmaster/source/browse/#svn/trunk/jazzmaster-examples/src/org/eiichiro/jazzmaster/examples/petstore/model の Item.java と Tag.java を例に説明します。前回の投稿で説明した通り、これらは多対多・双方向の関連を持っています。Google App Engine JPA がサポートしている、１対１の所有関連、１対多の所有関連、多対１の所有関連であれば、親となるエンティティのフィールドに子エンティティのインスタンス（のコレクション）を直接保持し、OneToOne, OneToMany, ManyToOne のアノテーションを付与することで、検索時に自動的に関連が解決されます。Google App Engine JPA がサポートしていない、多対多の関連や非所有関連の場合、自分が参照するエンティティのインスタンスを直接保持するのではなく、Key（のコレクション）を保持し、Key を使って参照先のエンティティを再検索するという方法で関連を解決します。 通常の JPA では、以下のように実装されていた Item.java と Tag.java は、 @Entity public class Item implements java.io.Serializable { private Collection<Tag> tags=new Vector<Tag>(); @ManyToMany(mappedBy = "items") public Collection<Tag> getTags() { return tags; } @Entity public class Tag implements java.io.Serializable { private Collection<Item> items= new Vector<Item>(); @ManyToMany @JoinTable(name = "TAG_ITEM", joinColumns = @JoinColumn(name = "TAGID", referencedColumnName = "TAGID") , inverseJoinColumns = @JoinColumn(name = "ITEMID", referencedColumnName = "ITEMID") ) public Collection<Item> getItems() { return items; } Google App Engine JPA ではこうなります。 @Entity public class Item implements java.io.Serializable { private String itemID; private Collection<String> tags = new Vector<String>(); // 使えない @ManyToMany(mappedBy = "items") public Collection<String> getTags() { return tags; } @Entity public class Tag implements java.io.Serializable { private String tagID; private Collection<String> items = new Vector<String>(); // 使えない @ManyToMany public Collection<String> getItems() { return items; } 登録は、こうやって // Item のインスタンスを生成 Item item1 = new Item("feline01", "Friendly Cat", "This black and white colored...", "images/anthony.jpg", "images/anthony-s.jpg", BigDecimal.valueOf(307.10), address1, sellerContactInfo1, 15, 3); item1.setItemID(Item.class.getSimpleName() + "1"); Item item2 = new Item("feline01", "Fluffy Cat", "A great pet for a hair stylist! Have...", "images/bailey.jpg","images/bailey-s.jpg", BigDecimal.valueOf(307), address2, sellerContactInfo2, 15, 5); item2.setItemID(Item.class.getSimpleName() + "2"); Item item3 = new Item("feline02", "Sneaky Cat", "My cat is so sneaky. He is so curious...", "images/bob.jpg", "images/bob-s.jpg", BigDecimal.valueOf(307.20), address3, sellerContactInfo3, 15, 7); item3.setItemID(Item.class.getSimpleName() + "3"); // Tag のインスタンスを生成 Tag awesome = new Tag("awesome"); awesome.setTagID(Tag.class.getSimpleName() + 1); awesome.setRefCount(5); Tag interesting = new Tag("interesting"); interesting.setTagID(Tag.class.getSimpleName() + 2); interesting.setRefCount(2); Tag cool = new Tag("cool"); cool.setTagID(Tag.class.getSimpleName() + 3); cool.setRefCount(10); // ItemID のリストを作って Tag に設定 List<String> awesomeItems = new ArrayList<String>(); awesomeItems.add(item1.getItemID()); awesomeItems.add(item2.getItemID()); awesomeItems.add(item3.getItemID()); awesomeItems.add(item4.getItemID()); awesomeItems.add(item5.getItemID()); awesome.setItems(awesomeItems); // TagID のリストを作って Item に設定。 List<String> item1Tags = new ArrayList<String>(); item1Tags.add(awesome.getTagID()); item1Tags.add(interesting.getTagID()); item1Tags.add(cool.getTagID()); item1.setTags(item1Tags); List<String> item2Tags = new ArrayList<String>(); item2Tags.add(awesome.getTagID()); item2Tags.add(interesting.getTagID()); item2Tags.add(cool.getTagID()); item2.setTags(item2Tags); List<String> item3Tags = new ArrayList<String>(); item3Tags.add(awesome.getTagID()); item3Tags.add(cool.getTagID()); item3.setTags(item3Tags); // これで多対多関連構築完了！非所有関連も同じように、自分で関連を組み立てる。 // Item を登録 entityManager.persist(item1); entityManager.persist(item2); entityManager.persist(item3); // Tag を登録 entityManager.persist(awesome); entityManager.persist(interesting); entityManager.persist(cool); 検索は、こうやります。 // Item を検索 Item item = entityManager.find(Item.class, itemID); // Item から TagID のリストを取得 Collection<String> tags = item.getTags(); // TagID のリストから Tag のリストを取得 Query tagQuery = entityManager.createQuery("SELECT t " + "FROM org.eiichiro.jazzmaster.examples.petstore.model.Tag t " + "WHERE t.tagID = :tagID"); for (Tag tag : (List<Tag>) tagQuery.setParameter("tagID", tags).getResultList()) { // 各 Tag から ItemID のリストを取得 Collection<String> items = tag.getItems(); // ItemID のリストから Item のリストを取得 Query itemQuery = entityManager.createQuery("SELECT i " + "FROM org.eiichiro.jazzmaster.examples.petstore.model.Item i " + "WHERE i.itemID = :itemID"); itemQuery.setParameter("itemID", items).getResultList(); } tagQuery と itemQuery のパラメータに、TagID のリストと ItemID のリストを直接設定していますが、これは、パラメータが Key 場合にのみ可能な実装方法です。パラメータが Key ではない場合、リストをイテレートしてリストの各エントリーごとにクエリーを発行する必要があります。次の Join クエリーの例を参照して下さい。 次は、Join クエリーです。Google App Engine データストアは Relational database ではありませんので、複数のエンティティのフィールドを結合して検索する、いわゆる Join クエリーを発行することができません。この場合も、クエリーを単一のエンティティを検索するクエリーに再分割して、１つ目のクエリーの結果を２つ目のクエリーのパラメータにするという形で Join クエリーと同じことをアプリケーションで行います。Relational database の SQL チューニングなどで、クエリ実行計画の解析をしたことのある人にはイメージが掴みやすいと思います。Relational database も、上記と同じプロセスで Join クエリーを実行し、最終的な結果セットを組み立てています。 通常の JPA では、以下のように実装されていた Join クエリーは、 /** * Value List Handler for items. Found by category * @param categoryID is the category id that the item belongs to * @param start position of the first result, numbered from 0 * @param chunkSize the maximum number of results to retrieve * @returns a List of Item objects */ @SuppressWarnings("unchecked") public List<Item> getItemsByCategoryVLH(String catID, int start, int chunkSize){ EntityManager em = emf.createEntityManager(); // i.productID と p.productID を Join Query query = em.createQuery("SELECT i FROM Item i, Product p WHERE " + "i.productID=p.productID AND p.categoryID = :categoryID AND i.disabled = 0" + " ORDER BY i.name"); List<Item> items = query.setParameter("categoryID",catID).setFirstResult(start).setMaxResults(chunkSize).getResultList(); em.close(); return items; } Google App Engine JPA ではこうなります。 @SuppressWarnings("unchecked") public List<Item> getItemsByCategoryVLH(String catID, int start, int chunkSize) { // まずは Product を検索 Query productQuery = entityManager.createQuery("SELECT p FROM org.eiichiro.jazzmaster.examples.petstore.model.Product p WHERE p.categoryID = :categoryID"); List<Product> products = productQuery.setParameter("categoryID", catID).getResultList(); List<String> productIDs = new ArrayList<String>(products.size()); // 検索した ProductID を使って for (Product product : products) { productIDs.add(product.getProductID()); } List<Item> items = new ArrayList<Item>(); // Item を検索、結果のマージ for (String productID : productIDs) { Query itemQuery = entityManager.createQuery("SELECT i FROM org.eiichiro.jazzmaster.examples.petstore.model.Item i WHERE i.productID = :productID"); items.addAll(itemQuery.setParameter("productID", productID).getResultList()); } // ソート Collections.sort(items, new Comparator<Item>() { public int compare(Item o1, Item o2) { return o1.getItemID().compareTo(o2.getItemID()); } }); // チャンク作成 if (items.size() < chunkSize) { chunkSize = items.size(); } return items.subList(start, chunkSize); 以上が Google App Engine データストアと JPA のポイントです。どうでしたか？Relational database に慣れてしまっている人は、頭を切り替えるのが少し大変かもしれませんね。 次回からは JSF と Servlet 環境の解説を行います。
投稿者
Eiichiro Uchiumi
時刻:
1:36
ラベル:
Google App Engine,
Java,
JPA
0
コメント:
コメントを投稿
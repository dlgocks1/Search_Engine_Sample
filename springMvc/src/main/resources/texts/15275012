最近、マウスを使って表示されてるヤカンを回して眺めるプログラムを実際に作った。その一部を掲載し、説明を加える。 
01: 
02:void Yakan::GetMatrix(GtMatrix &m) 
03:{ 
04:if(m_mouse8.GetMouse(0).key){ 
05: Float32 dx=mouse8.GetMouse(0).x-mouse8.GetMouse(-4).x; 
06: Float32 dy=mouse8.GetMouse(0).y-mouse8.GetMouse(-4).y; 
07: Float32 t=atan2(dy,dx); 
08: Float32 r=sqrt(dx*dx+dy*dy); 
09: 
10:  m_dqt.setUnitQt(); 
11:  m_dqt.calcZQt(t); 
12:  m_dqt.calcYQt(r*0.001f); 
13:  m_dqt.calcZQt(-t); 
14: } 
15: 
16: GTQUAT_Mult(&m_qt.m_qt, &m_dqt.m_qt, &m_qt.m_qt); 
17: 
18: m.SetTranslate(0.0f, 0.0f, 0.0f); 
19: m.MultQuatR(&m_qt.m_qt); 
20:} 
21: 
／／／／／ 
説明
02:　ヤカン用の３Ｄマトリクスを取得する関数。 このあと、 
draw(yakan_obj, m); 
04:　マウスが押されているときは、ヤカンをつまんだ感じで操作。マウスが押されてないときは、前回の動きが継続される。つまり、つまんで動かして放すとぐるぐる回り続ける。 
05:　現在と4vsync前のマウスの画面上の位置の差を取っている。 
07:　一旦、極座標に直す。これでＸＹ平面３６０度に対して平等なあつかい。 
10:  m_dqt（今回の変化量）を計算していく。マウスを放しているときは、m_dqtには前回の値が残る。 
11:  極座標の半径に比例した角度分、向こう側に回す。 
16:  m_qt（現在の（累積的な）クォータニオン）にm_dqt(今回変化量クォータニオン）を足しこむ。 
18:原点に持ってきて。 
19:クォータニオンをマトリクスに反映。 
／／／／／ 
マトリクスを使う場合との比較 
実は、上記で、m_qtやm_dqtのクォータニオンで値をキープする代わりにマトリクスを使っても同じく動作する。 
クォータニオンの利点は 
１．位置座標成分の誤差や”なにかの手違い”が入りこまない。 
・マトリクスだと「ずっと回してると位置がだんだんずれていく」なんてことも場合によっては考えられる。 
２．計算量がマトリクスより理論上少ない。スピードアップにつながる。（但し、実際にスピードが速いかどうかは環境次第） 
３．クォータニオン独自の関数（最短経路探索など）が使える。 
といったところ。 
／／／／／ 
ヤカンクォータニオン記事はこれでお終い。
アプリケーションを高速化したい！ 
そんなときに、テンプレートメタプログラミングはいかがでしょうか。 
備忘録的なアレですが、よろしくお願いします。 
ケース「１～１００までの結果を利用する」
たとえば「１～１００」までを足した結果は、いつでも５０５０です。これをプログラム中で利用する場合、５０５０を直接書いても良いですし、１～１００を足し算するプログラムを書いて実行時に結果を求めても良いはずです。 
これら二つの方法には、それぞれ長所・短所があります。 
▼５０５０を直接コードに埋め込むと・・・。 
短所：５０５０に何の意味があるかわからなくなる。 
長所：実行速度が速い。 
▼１～１００を足し算するプログラムを埋め込む方法。 
短所：不変な結果を利用するのに、いちいち実行時に計算しなければいけない（たとえプログラム起動時1度だけでも）。 
長所：５０５０の意味がわかる。 
それ、テンプレートメタプログラミングで。
どうにかして、５０５０の意味を失わず、実行速度も失わない、そんな夢のような方法はないものか・・・・・・・・・・ 
それ、テンプレートメタプログラミングで。 
C++のテンプレートは「コンパイル時」に埋め込まれます。これを利用して「５０５０」をコンパイル時に作り出すことが可能です。 
というわけで、さっそくサンプルプログラムから。 
#include <iostream> template<int x> struct Ls {     enum { value = Ls<x-1>::value + x }; }; template<> struct Ls<1> {     enum { value = 1}; }; int main() {     std::cout << Ls<10>::value << std::endl;     return 0; } 
このプログラムでは、C++のテンプレート、テンプレートの特殊化を用いて、コンパイル時実行を実現しています。 
まず、main()関数をコンパイルするときに、Ls構造体のテンプレートを利用しているLs<10>を展開しようとします。Ls<10>を展開するには、Ls<9>が必要で、さらにLs<9>にはLs<8>が必要で・・・、最終的に特殊化されたLs<1>まで展開します。 
イメージ的には、コンパイル時に以下のように展開されていきます。 
Ls<1>::value = 1; 
Ls<2>::value = Ls<1>::value + 2 = 3; 
.... 
Ls<8>::value = Ls<7>::value + 8 = 36; 
Ls<9>::value = Ls<8>::value + 9 = 45; 
Ls<10>::value = Ls<9>::value + 10 = 55; 
■まとめ 
というわけで、言葉で説明しようとするとどうしてもわかりにくくなってしまいますが、テンプレートを使えば、コンパイル時実行ができるのだと・・・、それをテンプレートメタプログラミングと呼ばれているのだ・・・と、それだけでも覚えてもらえればな・・・・、と思いました。 
ん・・・、やっぱ難しい。 
■備忘録。 
コンパイラによっては、Ls<1000>を利用できません。Ls<1000>を展開するためのメモリが足りなくなったり、展開に時間がかかってしまい、すなわちコンパイルがいつまで経っても終わらない・・・ということもあります。 
テンプレートメタプログラミングあたりになると、C++のコンパイラを作る人も大変だなぁ・・・・と思います。 
以上
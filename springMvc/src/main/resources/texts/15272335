9.15 gauche.parseopt - コマンドライン引数の解析 
Module: gauche.parseopt
このモジュールでは、コマンドラインオプションをパースするための便利な方法を定義
しています。インタフェースは Perl にヒントを受けたもので、複数のオプション引数を
伴う長い形式のオプションを便利に扱うことができます。
実際、Gauche でコマンドラインオプションをパースするにはいくつかの選択肢が
あります。SRFI-37 (srfi-37 - args-fold プログラム引数処理参照)では、
POSIX/GNU 互換の引数構文をパースするための関数的なインタフェースを提供しています。
SLIB は、getopt 互換のユーティリティを持っています。
要求される機能はアプリケーションごとに異なるので、
あなたの要求にフィットするものを選んで下さい。
High-level API 
Macro: let-args args (bind-spec … [. rest]) body …
このマクロはコマンドライン引数処理の最も典型的なパターンを扱います。
引数のリストargsを取り、bind-specで示される仕様をもとに
コマンドラインオプションを探してその値を変数に束縛し、それから
body …を実行します。
まず簡単な例を見てみましょう。このフォームが何をするか、だいたい想像できるのでは
ないかと思います。(より多くの例については下の“Examples”の項を参照して
ください)。
(define (main args)
(let-args (cdr args)
((verbose "v|verbose")
(outfile "o|outfile=s")
(debug-level "d|debug-level=i" 0)
(help "h|help" => (cut show-help (car args)))
. restargs
)
....))
(define (show-help progname)
...)
ローカル変数verboseは、コマンドラインオプション-vや--verbose
が与えられれば#tに、そうでなければ#fに束縛されます。
変数outputはオプション引数を取ると指定されており、例えば
-o out.txtのようにコマンドラインに指定されれば値"out.txt"が
束縛されます。debug-levelも似ていますが、オプション引数は
整数へと変換され、またデフォルト値0が指定されています。
help節では、単に値を束縛するだけでなくアクションを起動しています。
(註: 今のところlet-argsは-vと--vを区別しません。
-verboseと--verboseも同様です。将来、getopt_long(3)と
互換になるオプションを追加するかもしれません。)
最後のドットの後のrestargsは、オプションでないコマンドライン引数のリストを
受け取ります。
bind-specについて詳しく見てみましょう。
bind-specは次のいずれかの形式でなければなりません。
1. (var option-spec)
2. (var option-spec default)
3. (var option-spec => callback)
4. (var option-spec default => callback)
5. (else => handler)
6. (else formals body ...)
option-specの詳細については後で説明します。
特別な場合として、varを#fとすることもできます。
その場合、値は無視されます。
callbackでの副作用だけに関心がある場合に使えるでしょう。
対応するオプションがargsに与えられなかった場合、
varはdefaultが与えられていればその値に、
そうでなければ#fに束縛されます。
最後のbind-specには5か6の形式も許されます。
この節は、どのoption-specにもマッチしないコマンドラインオプションが
与えられた場合に選択されます。
5番目の形式では、handlerが3つの引数を伴って呼び出されます。
引数は、マッチしなかったコマンドラインオプション、
残りのコマンドライン引数、そして引数処理に戻るための継続手続きです。
handlerは与えられたコマンドラインオプションを処理した後、
オプション処理を続けたければ継続手続きに残りのコマンドライン引数を渡し、
オプション処理を打ちきりたければ残りのコマンドライン引数を戻り値として
返します。返された値は通常の(オプションでない)コマンドライン引数として扱われます。
束縛リストは、最後のcdrにシンボルを持つ不完全なリストであっても良く、
その場合はコマンドライン引数の残りのリストがその変数にと束縛されます。
default、callback、else節のフォーム等は
varの束縛の外側のスコープで評価されることに注意して下さい。
C における典型的な getopt や getopt_long の実装とは異なり、
let-args は与えられたコマンドライン引数の順番を変えません。
オプションでない引数(ハイフンで始まらない引数)に遭遇した時点でパースを
中止します。
パーサは、ハイフン2つのみの引数 `--' に遭遇すると、引数パーシングを
中止して`--' の後の引数のリストを返します。
全ての束縛が終了した後、body … が評価されます。
bodyは内部defineで始まっていても構いません。
Option spec 
option-spec は、オプションの名前とそのオプションがどのように引数を取るか
を指定する文字列です。オプションの名前には、アルファベット文字、数字、
アンダースコア、プラス記号、ハイフンが許されますが、ハイフンは最初の文字としては
使えません。すなわち、有効なオプションの名前は、#/[\w+][-\w+]*/ という
正規表現にマッチするものです。
オプションが引数を取る場合、名前の後ろに等号文字と引数の型を表現する文字を
付けることで指定できます。オプションは一つ以上の引数を取ることができます。
以下の文字がオプションの引数の型を表現するものとして認識されます。
s
文字列。
n
数値。
f
実数 (flonumに変換されます)。
i
正確な整数。
e
S式。
y
シンボル (引数はstring->symbolにより変換される)。
option-specの例を見てみましょう：
"name"
引数を取らないオプションの name を指定します。
"name=s"
オプション name は引数を一つ取り、それは文字列として渡されます。
"name=i"
オプション name は引数を一つ取り、それは正確整数として渡されます。
"name=ss"
オプション name は引数を二つ取り、両方とも文字列です。
"name=iii"
オプション name は3つの整数の引数を取ります。
"name=sf"
オプション name は2つの引数を取ります。一つ目は文字列で、
二つ目は数値です。
オプションにいくつかの別名がある場合は、"|" でつなげて書いておくことができます。
例えば"h|help"というoption-specは
"h"にも"help"にもマッチします。
コマンドラインでは、オプションは一つか二つのハイフンに続いて与えられます。
オプションの引数は、オプションそのものと等号記号でつながれていても構いません。
例えば、以下の全てのコマンドライン引数は、オプションの仕様、"prefix=s" に
マッチします。
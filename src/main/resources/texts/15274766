まえに、データ構造をまとめたんだけど、そこで 
で、保存したデータをどう処理するかは別の機会で・・・ 
と書いたので、ちょっと思いついた処理たちをメモメモ 
（ＪＡＶＡ　Ｖｅｒ６でやることを前提に書いてます）。 
■ソート 
Arrays.sort(ソートしたい配列); 
昇順：そのまま０から、最後まで配列出力 
逆順：最後から０まで出力 
＊レコードのある要素を基準にソートしたい場合 
ソートしたいレコード群（ファイル）の各レコードに対して 
・キーを作成し、 
・ハッシュマップにmap.put（上記キー,レコード）；の形で 
レコードをセット 
String keyList[] =(String[])map.keySet().toArray(new String[0]); 
で、キー項目を配列の形で取り出し（キーは文字列とする） 
Arrays.sort(keyList); 
keyList[]の０から最後まで、map.getして、レコードを取り出す 
■マージ（併合） 
マージしたい２つのレコード群（ファイル）の各レコードに対して 
まず、元になるレコード群（マスタ）から 
・キーを作成し、 
・ハッシュマップにmap.put（上記キー,レコード）；の形で 
レコードをセット 
次に、新しいレコード群（トランザクション）から 
・キーを作成し、 
・上記ハッシュマップと同じハッシュマップに 
map.put（上記キー,レコード）；の形でレコードをセット 
String keyList[] =(String[])map.keySet().toArray(new String[0]); 
で、キー項目を配列の形で取り出し（キーは文字列とする） 
keyList[]の０から最後まで、map.getして、レコードを取り出す 
＊この操作で、結果として、既存データは最新のもので置き換えられ、 
ないデータは追加される（マージされる） 
＊Javaでない場合は、HashMapを連想配列にかえる 
■最大最小の荒業 
Arrays.sort()する 
０番目の要素が最小値、最終版目（個数-1）が最大 
（ふつーに求めたほうが理論上は早いけど　＾＾；） 
■コード変換 
・コード変換表を読み込み、HashMapに 
map.put(コード,言葉）; 
の形で入力する 
・コードがきたら、map.get（コード）で、その言葉が取得できる 
→本来のハッシュマップの使い方 
■存在チェック 
・レコード群（ファイル、ＤＢ検索結果）の各レコードに対し、 
キーを作成し 
HashMapに　map.put(キー,レコード）; 
の形で入力する 
・存在チェックしたいキーに対して 
map.get(存在チェックしたいキー） 
して、null以外が返ってきたら、存在、nullなら存在しない 
■単一化（キー値が複数レコードに存在する場合、それをまとめて１レコード） 
・レコード群（ファイル、ＤＢ検索結果）の各レコードに対し、 
キーを作成し 
HashMapに　map.put(キー,レコード）; 
の形で入力する 
・そのハッシュマップに対して、 
String keyList[] =(String[])map.keySet().toArray(new String[0]); 
で、キー項目を配列の形で取り出し（キーは文字列とする） 
keyList[]の０から最後まで、map.getして、レコードを取り出す 
＊ここで、keyListをソートすると、キー順に出力する 
一方、入力する際に 
HashMapに　map.put(キー,配列の添え字番号）; 
にして、 
Integer valList[] =(Integer[])map.valueSet().toArray(new Integer[0]); 
として、値のリストをとり、この値リストをArrays.sortでソートして、 
値リスト（配列の添え字番号）に相当する元データを順に出力すると、 
入力順に単一化できる 
■分類 
・ハッシュマップ(mapとする）を用意する 
・レコード群（ファイル、ＤＢ検索結果）の各レコードに対し、 
HashMapから　map.get(分類コード）; 
で値をとってくる（返り値はArrayListのはず）。 
nullだったら（その分類のデータがない） 
ArrayListをnewして、返り値の変数にセット 
返り値の変数（ArrayList）に、レコードをadd 
map.put(分類コード,返り値の変数);する 
・全レコード上記の処理をしたら、 
String keyList[] =(String[])map.keySet().toArray(new String[0]); 
で、キー項目を配列の形で取り出し（キーは文字列とする） 
keyList[]の０から最後まで、map.getすると、分類されたレコード(ArrayList） 
がとれるので、これを順に出力すればＯＫ 
■分類ごとに、最大最小合計件数 
・ハッシュマップを用意する 
最大用なら、最大用で１つ 
最大最小を同時に求めるなら、 
最大用、最小用、（用途別に）１つづつ 
・レコード群（ファイル、ＤＢ検索結果）の各レコードに対し、 
（用途別の）HashMapから　map.get(分類コード）; 
で値をとってくる 
nullだったら（その分類のデータがない） 
最大、最小、合計値の場合、 
map.put(分類コード,そのデータの値);する 
件数だったら 
map.put(分類コード,1);する 
nullじゃなければ 
最大：保存してある値より、そのデータのほうが大きければ 
map.put(分類コード,そのデータの値);する 
最小：保存してある値より、そのデータのほうが小さければ 
map.put(分類コード,そのデータの値);する 
合計：保存してある値に、そのデータをプラスして 
map.put(分類コード,そのデータの値);する 
件数：保存してある値に、１プラスして 
map.put(分類コード,そのデータの値);する 
・全レコード上記の処理をしたら、 
String keyList[] =(String[])map.keySet().toArray(new String[0]); 
で、キー項目を配列の形で取り出し（キーは文字列とする） 
keyList[]の０から最後まで、map.getすると、分類された最大値などが全部 
取り出せる